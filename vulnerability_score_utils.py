import numpy as np
import pandas as pd
from matplotlib import pyplot as plt
import seaborn as sns
import matplotlib.patches as mpatches


def find_neighbors_within_k_in_train(experiment, orig_df, aux_df, index, orig_sens_pred, k=4):
    train_df = orig_df.copy()
    # test_df = test_df.drop([experiment.sensitive_column], axis=1)
    train_df = train_df.drop([experiment.y_column], axis=1)

    # test_df = aux_df.copy()
    train_df = train_df.drop([experiment.sensitive_column], axis=1)
    # train_df = train_df.drop([experiment.y_column], axis=1)

    numeric_columns = experiment.ds.ds.meta['num_columns']['zscaler'] + experiment.ds.ds.meta['num_columns']['minmaxscaler']

    aux_np = aux_df.drop([experiment.y_column, experiment.sensitive_column], axis=1).drop(numeric_columns, axis=1).to_numpy()
    aux_np = aux_np.astype(np.float32)
    aux_np = np.expand_dims(aux_np, 0)

    temp_np = train_df.drop(numeric_columns, axis=1).to_numpy()[index:index+1, :]
    # temp_np[:, 3] = orig_sens_pred
    # sensitive_column_index = orig_df.columns.tolist().index(experiment.sensitive_column)
    # temp_np[:, sensitive_column_index] = orig_sens_pred
    temp_np = temp_np.astype(np.float32)
    temp_np_2 = np.expand_dims(temp_np, 1)
    
    dist_matrix = np.count_nonzero(aux_np - temp_np_2, axis=2).ravel()
    # print(dist_matrix)

    aux_num_np = aux_df[numeric_columns].to_numpy()
    temp_num_np = train_df[numeric_columns].to_numpy()[index]
    std_np = np.array([experiment.ds.ds.std_dict[col] for col in numeric_columns])

    # print(dist_matrix)
    # print(np.abs(np.sum((aux_num_np-temp_num_np) / std_np, axis=1)))

    dist_matrix = dist_matrix + np.abs(np.sum((aux_num_np-temp_num_np) / std_np, axis=1))
    
    return dist_matrix <= k



def get_vulnerability_score(experiment, X, y, orig_df, index, k=3):
    dist_2_neighbours = find_neighbors_within_k_in_train(experiment, orig_df, orig_df, index, 1, k=k)
    X_temp = X.iloc[dist_2_neighbours]
    orig_y = y[index]
    dist_2_neighbours_y_values = y[dist_2_neighbours].ravel().astype(np.float)
    # print(dist_2_neighbours_y_values)
    dist_2_neighbours_w_same_y_indices = (orig_y == dist_2_neighbours_y_values)
    sensitive_column_index = orig_df.columns.tolist().index(experiment.sensitive_column)
    orig_sens_val = X.iloc[index][f'{experiment.ds.ds.meta["sensitive_column"]}_{experiment.ds.ds.meta["sensitive_positive"]}']
    return (X_temp.iloc[dist_2_neighbours_w_same_y_indices][f'{experiment.ds.ds.meta["sensitive_column"]}_{experiment.ds.ds.meta["sensitive_positive"]}'] == orig_sens_val).mean()


def draw_hist_plot(all_vuln_scores, correct_indices, incorrect_indices, attack_type='CSMIA', vuln_threshold=0.5):
    # fig, ax = plt.subplots()

    scores = all_vuln_scores
    # labels = ['Correct'] * len(correct_indices) + ['Incorrect'] * len(incorrect_indices)
    labels = ['Correct' if correct_indices[i] else 'Incorrect' for i in range(len(scores))]

    # Create a DataFrame
    df = pd.DataFrame({
        'Scores': scores,
        f'Prediction by {attack_type}': labels
    })

    # print(df)
    # df.to_csv('vvv.csv')
    n_bins=20
    bins_x = np.linspace(0, 1, n_bins+1)

    # Plot using sns.histplot
    plt.figure(figsize=(6, 5))
    histplot = sns.histplot(
        data=df, 
        x='Scores', 
        hue=f'Prediction by {attack_type}', 
        # hue_order=["Incorrect", "Correct"],
        element='bars', 
        stat='probability', 
        bins=bins_x, 
        linewidth=0.25,
        # palette=sns.dark_palette((20, 60, 50), input="husl"),
        palette={'Correct': 'grey', 'Incorrect': 'black'},
        alpha=0.5,
        multiple='stack'
    )
    # for patch in histplot.patches:
    #     if patch.get_facecolor()[:3] == (0.5, 0.5, 0.5):  # Grey color for 'Correct'
    #         patch.set_hatch('..')
    #         patch.set_edgecolor('grey')
    #     elif patch.get_facecolor()[:3] == (0.0, 0.0, 0.0):  # Black color for 'Incorrect'
    #         patch.set_hatch('//')
    #         patch.set_edgecolor((0.4, 0.4, 0.4))

    # # Manually create a legend
    # correct_patch = mpatches.Patch(facecolor='grey', edgecolor='grey', hatch='..', label='Correct')
    # incorrect_patch = mpatches.Patch(facecolor='black', edgecolor=(0.4, 0.4, 0.4), hatch='//', label='Incorrect')
    # plt.legend(handles=[correct_patch, incorrect_patch])

    # sns.histplot(all_vuln_scores[correct_indices], label='Correctly predicted examples', element='bars', stat='count', bins=25, linewidth=0.25, alpha=0.5, color="grey", hatch='..', edgecolor='grey')
    # sns.histplot(all_vuln_scores[incorrect_indices], label='Incorrectly predicted examples', element='bars', stat='count', bins=25, linewidth=0.25, alpha=0.25, color="black", hatch='//', edgecolor=(0.4, 0.4, 0.4))
    plt.axvline(x=vuln_threshold, color='black', linestyle='--', linewidth=1)
    plt.xlabel('Vulnerability Scores')
    plt.xticks(ticks=[0, 0.25, 0.5, 0.75, 1])
    plt.ylabel('Fraction of Records')
    plt.grid(True, linestyle='-', linewidth=0.25, axis='x')
    # # plt.title('Distribution of Predicted neighborhood similarity among k=4 dist neighbours from synthetic data for case 1 examples')
    # plt.legend(framealpha=1)
    # handles, labels = plt.ax.get_legend_handles_labels()
    # plt.legend(handles, labels)
    sns.despine()
    # plt.show()